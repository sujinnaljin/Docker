# 도커란 무엇인가?

## 서버 관리 방식의 변화

- 도커 등장 전 기존 서버 구축 플로우 -  유저 추가 -> 환경 설정 -> 방화벽 설정 -> 네트워크 설정 -> 의존성 설정 -> 파이썬 설치 -> 깃 클론 -> 패키지 설치 -> configuration -> migration ->  프록시 설정 -> Run!
- **도커** 등장 - **서로 다른 프로그램**이지만 **컨테이너라는 공통적인 형태**로 만들 수 있음. 컨테이너로 만들어두면, aws 건, azure 건 어디서든 그 컨테이너를 실행할 수 있음
- 그렇담 컨테이너는 **가상머신 같은**건가? 생각 들 수 있음. 가상머신이라는 것도 이미지 하나 잘 만들어두면 실행했을때 다른 것들에 영향 없이 뜨니까.
- 하지만 이는 반은 맞고 반은 틀린 말.
  - 가상 머신처럼 **독립적으로 실행**됨. 즉, 하나의 컨테이너 실행이 다른 컨테이너에 영향 x
  - But, 더 빠름. 가상머신은 리눅스 부팅부터해서 실행이 좀 걸리는데, 도커는 명령어 치자마자 바로 실행되는 느낌.
  - But,더 쉬움. docker compose up 명령어 하나만 알아도, 다른 사람이 작성해둔 도커 compose 파일 가지고 컨테이너 실행 가능
  - But, 더 효율적. 가상머신은 기본적으로 cpu, memory 느린데 도커는 효율적으로 동작.

- 🤔 : 흠..  젠킨즈 깔라면 뭐 자바를 깔던가 그래야하는데 그런 기반들을 다 슉샥 설정해주는건가

## 도커의 등장

- 도커 등장 전의 상황

  - 기존 서버 구축 플로우대로 설정을 잘해서 룰라리 쓰고 있었음
  - 그런데 어느날 갑자기 파이썬 버전업 됨 -> ㄷㄷ,, 이 위에서 돌아가는 프로그램들 엄청 많고, 이것들이 파이썬 쓰고 있는데,, 버전 올리기 무서워,,! 어떤 사이드 이펙드가 있을지 알고?!
  - 또는 파이썬에서 사용하는 Package 가 어느날 업데이트 됨.  -> 과연 업데이트 했을때 별일 없을까??
  - 또는 한땀 한땀 서버 구축 플로우 잘 했다고 생각하고, 마지막에 Run 시켜봤는데 에러 로그 주루룩 뜨면서 잘 안될수도? -> 모든 과정을 잘해야하고, 각 단계마다 어떤 문제가 생길지 예상할 수 있어야함
  - 이렇게 어느 한곳에서라도 문제가 생기면 와르르맨션행

- 그럼 이런 전통적인 방식에서 컨테이너 방식으로 어떻게 바꼈을까? -> 서버 상태를 관리하기 위한 노오오력의 결과

- 노오오오력의 종류로는

  - **문서화** 잘해둬서 따라만하면 설치 등 되게 -> 문제는,, 문서가 정확한걸까? 업데이트는 된걸까? 다른 os 에서는 어떻게 설치하는거지? 

  - 문서 관리로는 부족하다,,싶어서 **상태 관리** 도구 등장 -> 기존 문서에 따라쳐야할 명령어등을 써놓는 대신, **설정 파일**에 "아파치" 설치 라고 명시해두고 프로그램을 돌리면, 이 프로그램이 설정파일을 보고 사람이 하는 것처럼 명령어를 치는,, -> 코드로 관리되기 때문에 협업 및 버전관리에 좋음. 하지만 러닝커브 있음. 또 하나의 서버에 아파치 1.1, 아파치 1.2 등 다른 버전 여러개 설치 어떻게하려면 각 경로 다르게 지정해줘야하고..

  - **가상머신**을 관리하는 서버 만들어두고, 이 서버에 가상머신 한개씩 띄우면 되잖아? 각 머신 마다 젠킨즈도 올리고, 워드프레서도 올리고, 채팅도 올리고 하자. 그러면 한 서버에 여러개 설치도 쉽고(서로 영향 없음), 현재 상태도 저장할 수 있고! -> 근데 처음부터 다시 세팅하려면 어떡하지,, 서버 이미지 공유는 어떻게하지,,뭐 메일로 보낼수도 없고, 구글 드라이브에 올려놔야하나? 그리고 드럽게 느리네!

  - **자원 격리** (고오오급 기능). 젠킨즈나 워드 프로세서 같은 프로세스를 가상으로 분리하자! 파일이나 디렉토리도 가상으로 분리해서 각 프로세스가 사용하는 디렉토도 실제로 같은데인데 서로 다른곳으로 보이게해! cpu, I/O, memory 도 그룹별로 제한해! 리눅스 커널 기능 이용해서 얘는 얼마 이상 사용못하게해! 리눅스 기능을 이용한 빠르고 효율적인 관리방법. -> 너어무 어려워. 물론 갓글은 사용

    => 이러한 어렵고 복잡한 기술을 설치 / 사용하기 쉽게 **도 커 등 장**

- 도커의 등장

  - **컨테이너** - 격리된 환경에서 작동하는 프로세스

  - **리눅스 커널**의 여러 기능 활용

  - 하드웨어 가상화 기술보다 가벼움

  - 이미지 단위로 프로세스 실행환경 구성

    > 이미지? 
    >
    > **실제 작업 복사본을 만드는 데 필요한 모든 정보**가 들어있는 파일
    >
    > 도커 이미지 - 서비스 운영에 필요한 서버 프로그램, 소스코드 및 라이브러리, 컴파일된 실행 파일을 묶는 형태

## 도커란

- vm 과 비교했을때 hostOS 위에 guestOS 가 올라가는게 아니라, 그냥 격리만 해주는 역할이라 빠름
  
  <img width="758" alt="스크린샷 2022-08-13 오후 8 48 34" src="https://user-images.githubusercontent.com/20410193/184492834-2bfa8953-62bb-4e51-b7f7-729de2d2852c.png">
  
- 도커의 특징

  - 확장성 , 이식성

    **해당 서버에 도커가 설치**되어있다면 **어디서나 컨테이너 실행** 가능

    쉽게 개발 서버를 만들 수 있고, 테스트 서버 생성도 간편 (🤔 다른 컨테이너에서 설정만 다르게 해주면 되어서 그런건가?)

  - 표준성

    도커를 사용하지 않는 경우, ruby, node.js, go, php 로 만든 서비스들의 배포 방식은 제각각 다름 -> **컨테이너라는 표준**으로 서버를 배포하므로 **모든 서비스의 배포 과정이 동일**해짐

  - 이미지

    **이미지에서 컨테이너를 생성**하기 때문에, 반드시 이미지를 만드는 과정이 필요. Dockerfile 을 이용해 이미지 만들고 처음부터 재현 가능. (이미지는 컨테이너를 실행하기 위한 압축파일이라고 생각)

    빌드 서버에서 이미지를 만들면 -> 해당 이미지를 이미지 저장소에 저장하고 -> 필요한 곳 (ex. 운영 서버) 에서 이미지를 불러오는 방식으로 사용

  - 설정 관리

    **설정**은 보통 **환경 변수**로 제어. `MYSQL_PASS = password` 와 같이 **컨테이너를 띄울때 환경변수를 같이** 지정. **하나의 이미지**가 **환경 변수에 따라 동적으로 설정파일을 생성**하도록 만들어져야함.

  - 자원 관리

    컨테이너는 **삭제 후 새로 만들**면 **모든 데이터가 초기화**됨.

    따라서 업로드 파일을 **외부 스토리지**와 링크하여 사용하거나, S3 같은 **별도의 저장소**가 필요

    세션이나 캐시를 memcahed 나 redis 같은 **외부로 분리**

  - 🤔 캡틴이 도커로 배포하려는건,, 젠킨즈 깔라면 뭐 java 설치하고 기타 작업할 것들이 있는데, 도커를 이용하면 mac 에 도커 설치하고, 그냥 젠킨즈 이미지 다운받아서 container 만 실행하면 돼서?

- 도커가 가져온 변화

  - 클라우드 이미지보다 관리 쉬움
  - 다른 프로세스와 격리되어 가상머신처럼 사용하지만 성능저하 (거의) 없음
  - 리눅스의 복잡한 기술 (namespace, cgroups, network,,,) 을 몰라도 사용할 수 있음
  - 이미지 빌드 기록 남음
  - 코드와 설정으로 관리 -> 재현 및 수정 가능 
  - 오픈 소스 -> 특정 회사 기술에 종속되지 않음

- 모든걸 컨테이너로 만들 수 있음

  <img width="700" alt="image" src="https://user-images.githubusercontent.com/20410193/184492843-d4eaf19c-8789-4fcc-ac3a-929a2669c852.png">

## 도커의 미래 (컨테이너의 미래)

- 도커는 컨테이너 기술을 사용

- 초반에는 컨테이너 기술을 사용하기 위해 대부분 도커를 사용했는데, 지금은 도커 말고도 좋은 기술이 많이 나와서 도커의 위치가 조금씩 흔들림

- 하지만 컨테이너는 그대로 사용하기 때문에 컨테이너의 미래에 대해 알아보자

- 도커 - 하나의 프로그램을 관리하는 방식

- 쿠버네티스 - 여러대의 서버와 여러개의 서비스를 관리하기 쉽게. 즉 **쿠버네티스 안에 여러개의 도커**가 있는거. (🤔 하나의 도커가 하나의 서버로 치환해서 생각하면 되는건가? 도커 위에서 여러 컨테이너, 즉 서비스를 관리할 수 있는거고. 그래서 저번에 만햄이 설명한 Pod 개념이 하나의 도커, 즉 서버라고 생각하면 되는건가)

- 쿠버네티스의 대표적 기능은 

  - **스케줄링**

    - **컨테이너**를 **적당한 서버**에 배포해주는 작업
    - 여러 대의 서버 중 **가장 할일 없는 서버**에 배포하거나, 그냥 차례대로 배포 또는 아예 랜덤하게 배포
    - 컨테이너 개수를 여러개로 늘리면 **적당히 나눠서 배포**하고, 서버가 **죽으면** 실행중이던 컨테이너를 **다른 서버**에 띄워줌

  - **클러스터링**

    - **여러개**의 서버를 **하나의 서버처럼** 사용. 많게는 수천대의 서버를 하나의 클러스터로 구성 가능

      예를 들어 어떤 서비스가 3번 서버에 있으면 그곳을 접속하고 사용하는게 아니라, **중앙에 있는 api 서버**를 통해서 **모든 서버를 한곳에서 관리** 가능

    - 여기저기 **흩어져 있는 컨테이너**도, **가상 네트워크**를 이용해서 ip 따로 할당해서 **마치 같은 서버에 있는 것처럼** 쉽게 통신 가능

  - **서비스 디스커버리**

    - 서비스를 찾아주는 기능

    - **클러스터 환경**(여러개의 서버가 하나의 서버처럼 묶여있는 상황)에서 **컨테이너**는 **어느 서버에 생성**될지 **알 수 없**고, 다른 서버로 **이동**할 수도 있음

    - 따라서 **컨테이너와 통신**을 하기 위해서 **어느 서버에서 실행**중인지 알아야 함.

      예를 들어 1번 서버에 워드 프레스가 떠있고, 2번 서버에 mysql 이 떠있음. 이 둘을 연결해줘야하는 상황에서, 이 서비스들이 어디 서버에 떠있는지 정확히 알아야하는 것.

    - 따라서 컨테이너가 생성되고 중지될때 어딘가에 ip 와 port 같은 정보를 업데이트 해줘야함. 

    - key-value 스토리지에 정보를 저장할 수도 있고, 내부 dns 서버를 이용해서  ip 가 아니라 도커 컨테이너 이름으로 바로 접근 가능.

